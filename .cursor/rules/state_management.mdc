---
alwaysApply: true
---
# State Management (Riverpod 3.x)

## Provider 선언
```dart
// ✅ GOOD: Code generation 사용
@riverpod
FutureOr<List<Trainer>> trainerList(Ref ref) async {
  final repo = ref.watch(trainerRepositoryProvider);
  return repo.getTrainers();
}

// ✅ GOOD: KeepAlive가 필요한 경우
@Riverpod(keepAlive: true)
Dio dio(Ref ref) {
  final dio = Dio(BaseOptions(baseUrl: Env.apiUrl));
  dio.interceptors.add(AuthInterceptor(ref));
  return dio;
}

// ❌ BAD: Manual provider 선언
final manualProvider = Provider((ref) => ...);
```

## 핵심 규칙
- 모든 Provider는 `@riverpod` 또는 `@Riverpod(keepAlive: true)` 사용
- Provider는 순수 함수: 내부에서 side-effect 발생 금지
- `ref.read()`는 이벤트 핸들러 내부에서만 사용, build 메서드에서는 `ref.watch()` 사용
- `AsyncValue`는 반드시 `.when()` 또는 `.map()` 으로 처리
- `ref.invalidate()`로 캐시 삭제, `ref.refresh()`로 강제 리로드
- `keepAlive: true`는 메모리 누수 위험 고려 후 신중하게 사용

## AsyncValue 패턴
```dart
// ✅ GOOD: when으로 모든 상태 처리
ref.watch(dashboardProvider).when(
  data: (data) => DashboardContent(data: data),
  loading: () => const LoadingIndicator(),
  error: (error, stack) => ErrorView(message: error.toString()),
);

// ✅ GOOD: maybeWhen으로 일부 상태만 처리
ref.watch(dashboardProvider).maybeWhen(
  data: (data) => DashboardContent(data: data),
  orElse: () => const SizedBox.shrink(),
);
```

## 메모리 관리
```dart
// ✅ GOOD: autoDispose로 자동 해제
@riverpod
FutureOr<List<Trainer>> trainerList(TrainerListRef ref) async {
  // 화면을 벗어나면 자동으로 dispose됨
  return ref.watch(trainerRepositoryProvider).getTrainers();
}

// ❌ BAD: keepAlive로 메모리 누수 위험
@Riverpod(keepAlive: true)
FutureOr<List<Trainer>> trainerList(TrainerListRef ref) async {
  // dispose되지 않아 메모리 누수 가능성
}
```
